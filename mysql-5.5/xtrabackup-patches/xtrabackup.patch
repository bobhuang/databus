--- /export/home/eng/apachev/xtrabackup-1.6/xtrabackup.c	2011-04-12 13:32:59.000000000 +0000
+++ xtrabackup.c	2011-07-06 00:05:57.244263109 +0000
@@ -714,6 +714,8 @@
 #define INNOBASE_WAKE_INTERVAL	32
 ulong	innobase_active_counter	= 0;
 
+static int should_copy_table(const char* path);
+
 /* ======== Datafiles iterator ======== */
 typedef struct {
 	fil_system_t *system;
@@ -740,6 +742,105 @@
 	return it;
 }
 
+static int should_copy_table(const char* path)
+{
+  int i, regres = 0;
+  char path_buf[FILENAME_MAX];
+  const char* p_src;
+  char* p_dst, *p_dst_end;
+  int seen_slash = 0;
+  
+  p_src = path;
+  p_dst = path_buf;
+  p_dst_end = path_buf + sizeof(path_buf);
+  
+  for (;*p_src && p_dst < p_dst_end; p_src++)
+  {
+    if (*p_src == '/')
+    {
+      if (p_src > path)
+        *p_dst++ = '.';
+      seen_slash = 1;
+    }  
+    else if (*p_src == '.' && seen_slash)
+      break;  
+    else  
+      *p_dst++ = *p_src;
+  }
+  
+  if (p_dst == p_dst_end)
+    return 0;
+  
+  *p_dst = 0;
+  
+  if (xtrabackup_tables)
+  {
+    for (i = 0; i < tables_regex_num; i++) 
+    {
+      if ((regres = regexec(&tables_regex[i], path_buf, 1, tables_regmatch, 
+           REG_EXTENDED) 
+         != REG_NOMATCH))
+      {
+        return 1;
+      }  
+    } 
+    
+    return 0;
+  }
+  
+  if (xtrabackup_tables_file)
+  {
+    xtrabackup_tables_t* table;
+    char* p;
+    char* tmp1 = 0, *tmp2 = 0;
+    seen_slash = 0;
+    
+    if (*path == '/')
+      path++;
+    
+    for (p = (char*)path; *p; p++)
+    {
+      if (*p == '/')
+        seen_slash = 1;
+      
+      if (*p == '.')
+      {
+        if (!tmp1 && !seen_slash)
+        {
+          tmp1 = p;
+          *tmp1 = '/';
+        }
+        else if (seen_slash && !tmp2)
+        {
+          tmp2 = p;
+          *tmp2 = 0;
+        }
+      }
+    }
+    HASH_SEARCH(name_hash, tables_hash, ut_fold_string(path),
+#ifdef INNODB_VERSION_SHORT
+          xtrabackup_tables_t*,
+#endif
+          table,
+#ifdef INNODB_VERSION_SHORT
+          ut_ad(table->name),
+#endif
+              !strcmp(table->name, path));
+    
+    if (tmp1)
+      *tmp1 = '.';
+    
+    if (tmp2)
+      *tmp2 = '.';
+    
+    if (!table)
+    {  
+      return 0;
+    }  
+  }
+ return 1;  
+}
+
 static
 fil_node_t *
 datafiles_iter_next(datafiles_iter_t *it, ibool *space_changed)
@@ -2453,9 +2554,9 @@
 	info.page_size = 0;
 
 #ifdef XTRADB_BASED
-	if (xtrabackup_tables && (!trx_sys_sys_space(node->space->id)))
+	if ((!trx_sys_sys_space(node->space->id)))
 #else
-	if (xtrabackup_tables && (node->space->id != 0))
+	if ((node->space->id != 0))
 #endif
 	{ /* must backup id==0 */
 		char *p;
@@ -2463,6 +2564,7 @@
 		char *next, *prev;
 		char tmp;
 		int i;
+    int skip_copy = 0;
 
 		p = node->name;
 		prev = NULL;
@@ -2483,65 +2585,15 @@
 		p[p_len] = 0;
 		*(p - 1) = '.';
 
-		for (i = 0; i < tables_regex_num; i++) {
-			regres = regexec(&tables_regex[i], prev, 1, tables_regmatch, 0);
-			if (regres != REG_NOMATCH)
-				break;
-		}
+    if (!should_copy_table(prev))
+    {
+      skip_copy = 1;
+    }
 
 		p[p_len] = tmp;
 		*(p - 1) = SRV_PATH_SEPARATOR;
 
-		if ( regres == REG_NOMATCH ) {
-			printf("[%02u] Copying %s is skipped.\n",
-			       thread_n, node->name);
-			return(FALSE);
-		}
-	}
-
-#ifdef XTRADB_BASED
-	if (xtrabackup_tables_file && (!trx_sys_sys_space(node->space->id)))
-#else
-	if (xtrabackup_tables_file && (node->space->id != 0))
-#endif
-	{ /* must backup id==0 */
-		xtrabackup_tables_t* table;
-		char *p;
-		int p_len;
-		char *next, *prev;
-		char tmp;
-
-		p = node->name;
-		prev = NULL;
-		while ((next = strstr(p, SRV_PATH_SEPARATOR_STR)) != NULL)
-		{
-			prev = p;
-			p = next + 1;
-		}
-		p_len = strlen(p) - strlen(".ibd");
-
-		if (p_len < 1) {
-			/* unknown situation: skip filtering */
-			goto skip_filter;
-		}
-
-		/* TODO: Fix this lazy implementation... */
-		tmp = p[p_len];
-		p[p_len] = 0;
-
-		HASH_SEARCH(name_hash, tables_hash, ut_fold_string(prev),
-#ifdef INNODB_VERSION_SHORT
-			    xtrabackup_tables_t*,
-#endif
-			    table,
-#ifdef INNODB_VERSION_SHORT
-			    ut_ad(table->name),
-#endif
-	    		    !strcmp(table->name, prev));
-
-		p[p_len] = tmp;
-
-		if (!table) {
+		if ( skip_copy ) {
 			printf("[%02u] Copying %s is skipped.\n",
 			       thread_n, node->name);
 			return(FALSE);
@@ -3312,10 +3364,11 @@
 			 ptr1);
 		*ptr2 = SRV_PATH_SEPARATOR;
 
-		if (my_mkdir(path, 0777, MYF(0)) < 0 && my_errno != EEXIST) {
+		if (should_copy_table(ptr1) && 
+      my_mkdir(path, 0777, MYF(0)) < 0 && my_errno != EEXIST) {
 			fprintf(stderr,
-				"xtrabackup: Error: cannot mkdir %d: %s\n",
-				my_errno, path);
+				"xtrabackup: Error: cannot mkdir %s: errno %d\n",
+				path, my_errno);
 			return -1;
 		}
 	}
@@ -3631,7 +3684,8 @@
 	if (xtrabackup_extra_lsndir
 		&&!my_stat(xtrabackup_extra_lsndir,&stat_info,MYF(0))
 		&& (my_mkdir(xtrabackup_extra_lsndir,0777,MYF(0)) < 0)){
-		fprintf(stderr,"xtrabackup: Error: cannot mkdir %d: %s\n",my_errno,xtrabackup_extra_lsndir);
+		fprintf(stderr,"xtrabackup: Error: cannot mkdir %s:"
+		 " errno %d\n",xtrabackup_extra_lsndir, my_errno);
 		exit(EXIT_FAILURE);
 	}
 
@@ -3641,7 +3695,7 @@
 	/* create target dir if not exist */
 	if (!my_stat(xtrabackup_target_dir,&stat_info,MYF(0))
 		&& (my_mkdir(xtrabackup_target_dir,0777,MYF(0)) < 0)){
-		fprintf(stderr,"xtrabackup: Error: cannot mkdir %d: %s\n",my_errno,xtrabackup_target_dir);
+		fprintf(stderr,"xtrabackup: Error: cannot mkdir %s: errno %d\n",xtrabackup_target_dir, my_errno);
 		exit(EXIT_FAILURE);
 	}
 
