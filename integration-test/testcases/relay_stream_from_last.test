#!/bin/bash
# StreamFromLatest Test
###############################################################################################################
#################################    TESTCASE DEFINITION                 ######################################
## 1. Setup the Relay
## 2. Start Consumer 1 with enableReadLatestOnRelayFallOff flag set to true (no bootstrap)
## 4. Generate Events till the relay buffer is almost full 
## 5. Pause Consumer 1 after it reached the relay.maxScn
## 6. Generate events in the relay till we overwrite the latest
##    event from the previous production
## 7. Sleep for some time to make sure RelayPullThread also pauses because of lack of space in CLient event
##    buffer
## 8. Note the MaxScn of the Client which is named as MissedScnLow.
## 9. Note the MaxScn of the Relay which is named as MissedScnHigh.
## 10. Resume Consumer 1. Verify in logs if it does not go to bootstrap mode or gets suspended.
## 11. Generate events in the relay till till we overwrite the latest
##      event from the previous production
## 12. Wait for consumer 1 (both RelayPullTHread and RelayDispatcher) to read all the events in buffer.
## 13. Verify that all the relay events except those in the range (MissedScnLow, MissedScnHigh) are read 
##     exactly by consumer1.
###############################################################################################################

#******************************************************
# set TEST_NAME before calling setup_env.inc
#******************************************************
export TEST_NAME=relay_stream_from_last.test
#******************************************************
# sets up common environmnet variables and 
source setup_env.inc

relay_port_1=${RELAY_PORT_BASE}
relay_event_dump_file=${WORK_DIR_FROM_ROOT}/liar_relay_${relay_port_1}_`date +%Y_%m_%d_%H_%M_%S`.log
relay_filtered_event_dump_file=${WORK_DIR_FROM_ROOT}/liar_relay_${relay_port_1}_`date +%Y_%m_%d_%H_%M_%S`.log.filtered
relay_gc_file=${WORK_DIR_FROM_ROOT}/liar_relay_gc.log
consumer_1_port=${CLIENT_PORT_BASE}
consumer_1_events_trace=${WORK_DIR_FROM_ROOT}/liar_consumer_1.events
consumer_1_server_log=${VIEW_ROOT}/${LOG_DIR_FROM_ROOT}/liar_consumer_1_`date +%Y_%m_%d_%H_%M_%S`.log
cp_dir=${WORK_DIR_FROM_ROOT}/consumer_checkpoint_liar

# 10M buffer , event dump file 
$SCRIPT_DIR/dbus2_driver.py -c liar_relay -o start --jvm_gc_log=${relay_gc_file} --cmdline_props="databus.relay.container.httpPort=${relay_port_1};databus.relay.eventBuffer.maxSize=102400;databus.relay.eventBuffer.trace.option=file;databus.relay.eventBuffer.trace.filename=${relay_event_dump_file};databus.relay.eventBuffer.trace.appendOnly=false"

# start the consumer 1 (enableReadLatestOnRelayFallOff = true)
$SCRIPT_DIR/dbus2_driver.py -c liar_consumer -o start --http_port=${consumer_1_port} --relay_port=${relay_port_1} --logfile=${consumer_1_server_log} --dump_file=${consumer_1_events_trace} --cmdline_props="databus.client.runtime.relay(1).name=DefaultRelay2;databus.client.runtime.relay(1).port=${relay_port_1};databus.client.runtime.relay(1).sources=com.linkedin.events.liar.memberrelay.LiarMemberRelay,com.linkedin.events.liar.jobrelay.LiarJobRelay;databus.client.checkpointPersistence.fileSystem.rootDirectory=${cp_dir};databus.client.checkpointPersistence.clearBeforeUse=true;databus.client.enableReadLatestOnRelayFallOff=true;databus.client.connectionDefaults.eventBuffer.maxSize=102400;databus.client.connectionDefaults.enablePullerMessageQueueLogging=true"

echo "Generating Events !!";
# generate events
#echo == Event generation started. Please check $WORK_DIR/profile_relay_event_trace and ${consumer_1_events_trace}
$SCRIPT_DIR/dbus2_gen_event.py -e 500 -s 20,21 --percent_buff=80 --wait_until_suspend --server_port=${relay_port_1}

#Wait for consumer to catchup. Note down the MaxScn
echo "Waiting for consumer to catchup"
Consumer1MaxScn1=`$SCRIPT_DIR/dbus2_driver.py -c liar_consumer --http_port=${consumer_1_port} -o wait_event --relay_port=${relay_port_1} --timeout=60 | grep "Wait maxWinScn:" | awk '{print $NF}' FS=:`

echo "Consumer 1 Max Scn before pause : $Consumer1MaxScn1"

echo "Pausing Consumer 1"
$SCRIPT_DIR/dbus2_driver.py -c liar_consumer --http_port=${consumer_1_port} --relay_port=${relay_port_1} -o pause

sleep 10

echo "Generating events after pause ...";
$SCRIPT_DIR/dbus2_gen_event.py -e 5000 -s 20,21 --resume_gen --percent_buff=100 --wait_until_suspend --server_port=${relay_port_1}

sleep 10

echo "Generating events after pause ...";
# generate events so that it overwrites the buffer
$SCRIPT_DIR/dbus2_gen_event.py -e 50000 -s 20,21 --resume_gen --percent_buff=150 --wait_until_suspend --server_port=${relay_port_1}

echo "Sleeping for 180 sec"
sleep 180

echo "Finding Missed SCN Window"
MissedScnLow=`$SCRIPT_DIR/dbus2_driver.py -c liar_consumer --http_port=${consumer_1_port} -o maxscn`;
MissedScnHigh=`$SCRIPT_DIR/dbus2_driver.py -c liar_relay --http_port=${relay_port_1} -o maxscn`;
RelayLowScn=`$SCRIPT_DIR/dbus2_driver.py -c liar_relay --http_port=${relay_port_1} -o minscn`;

echo "MissedScnLow = $MissedScnLow"
echo "MissedScnHigh = $MissedScnHigh"
echo "RelayLowScn = $RelayLowScn"
echo "Expecting events with SCN between $MissedScnLow and $MissedScnHigh (exclusive) to be not present in client buffer"

echo "Resuming Consumer 1"
# Resume  consumer1
$SCRIPT_DIR/dbus2_driver.py -c liar_consumer --http_port=${consumer_1_port} --relay_port=${relay_port_1} -o resume

# look at the log. Should not find ScnNotFound
echo ==GREP ERROR
echo "Verifying if Remote ScnNotFoundException is received by consumer:"
grep "Remote exception received: com.linkedin.databus.core.ScnNotFoundException" ${consumer_1_server_log} | wc -l | perl -lane '{ my $a = $_; chomp($a); if ($a >= 1 ) { print $a; exit 1; } else { exit 0;} }'

stat_txt="Test $0 Step 1"
source report_pass_fail.inc

stat_txt="Test $0 Step 2"
echo "Verifying if consumer proceeded with readFromLatest stream Call:"
grep "Got SCNNotFoundException but Read Latest SCN Window and bootstrap are disabled" ${consumer_1_server_log} | wc -l | perl -lane '{ my $a = $_; chomp($a); if ($a > 0 ) { print $a; exit 1; } else { exit 0;} }'
source report_pass_fail.inc

# generate events so that it overwrites the buffer
$SCRIPT_DIR/dbus2_gen_event.py -e 500 -s 20,21 --resume_gen --percent_buff=80 --wait_until_suspend --server_port=${relay_port_1}

Consumer1MaxScn2=`$SCRIPT_DIR/dbus2_driver.py -c liar_consumer --http_port=${consumer_1_port} -o wait_event --relay_port=${relay_port_1} --timeout=60 | grep "Wait maxWinScn:" | awk '{print $NF}' FS=:`

echo "MissedScnLow = $MissedScnLow"
echo "MissedScnHigh = $MissedScnHigh"
echo "RelayLowScn = $RelayLowScn"
echo "Consumer 1 Max Scn before pause : $Consumer1MaxScn1"
echo "Consumer 1 Max Scn after pause : $Consumer1MaxScn2"

# Make sure Client Dispatcher consumes
sleep 10

stat_txt="Stop Consumer"
$SCRIPT_DIR/dbus2_driver.py -c liar_consumer --http_port=${consumer_1_port} -o stop
source report_pass_fail.inc
$SCRIPT_DIR/dbus2_driver.py -c liar_relay -o stop

## Filter Events to generate the expected resultset
cat ${VIEW_ROOT}/$relay_event_dump_file | perl $SCRIPT_DIR/filterJSonEventsBySequence.pl ${MissedScnLow} ${MissedScnHigh} 0 0 > ${VIEW_ROOT}/${relay_filtered_event_dump_file}

## Compare events
$SCRIPT_DIR/dbus2_json_compare.py -s ${VIEW_ROOT}/${relay_filtered_event_dump_file}  ${VIEW_ROOT}/${consumer_1_events_trace}
stat_txt="Test $0 Step 3"
source report_pass_fail.inc

final_report=1
stat_txt="Relay Pull Thread Validation"
cat ${VIEW_ROOT}/${WORK_DIR_FROM_ROOT}/*log* | perl $SCRIPT_DIR/validateRelayPullerMessageQueue.pl
source report_pass_fail.inc

exit $all_stat
