|| Contents ||
| {toc} |

h1. Introduction

The following wiki focuses on the implementation internals of the Databus v1 relays and clients. The document covers:

* A high-level overview of the Spring wiring of the Databus-related beans
* Main interfaces
* Main classes and their configuration options

Note: Whenever a class or an interface is parametrized on {{<K,V>}}, K denotes the key type of the Databus events and V denotes the Java class of the events (aka DTO class).

Code can be found at:

* Java classes: [svn+ssh://svn.corp.linkedin.com/netrepo/container/trunk/databus|http://viewvc.corp.linkedin.com/viewvc/netrepo/container/trunk/databus]
* Relays spring components and WARs: {{databus}} directory in network e.g. [svn+ssh://svn.corp.linkedin.com/netrepo/network/branches/BR_REL_1132/databus|http://viewvc.corp.linkedin.com/viewvc/netrepo/network/branches/BR_REL_1132/databus]
* Client callback implementations, spring components, and WARs: domain modules e.g [svn+ssh://svn.corp.linkedin.com/netrepo/network/branches/BR_REL_1132/anet|http://viewvc.corp.linkedin.com/viewvc/netrepo/network/branches/BR_REL_1132/anet] -- svn+ssh://svn.corp.linkedin.com/netrepo/network/branches/BR_REL_1132/anet/databus-impl|http://viewvc.corp.linkedin.com/viewvc/netrepo/network/branches/BR_REL_1132/anet/databus-impl]

h1. Spring Setup

h2. Relays

Below, we've used the spring wiring for the ANET relay ([svn+ssh://svn.corp.linkedin.com/netrepo/network/branches/BR_REL_1132/databus/anet-relay-cmpt|http://viewvc.corp.linkedin.com/viewvc/netrepo/network/branches/BR_REL_1132/databus/anet-relay-cmpt]) to describe the relay setup. Other relays follow the same pattern. 

!http://viewvc.corp.linkedin.com/viewvc/netrepo/databus2/trunk/doc/engineering_docs/databus_v1_relay_anatomy.png?view=co|width=50%!

These are the main flows:

* {color:cyan}Reading from the Oracle database and writing to the memory event buffer{color}
* {color:green}Accepting requests from the clients and reading from the memory event buffer{color}
* {color:brown}Accepting a requests from a client which has fallen off the event buffer and proxying a direct response from the Oracle database{color}
* {color:magenta}Storing the contents of the buffer to a cache file on service shutdown and loading the cache file on service startup.{color} 

*Updates from the Oracle database* are monitored and read from an object of type {{OracleEventsMonitor}} which is created by the {{eventMonitorFactory}} bean. The {{OracleEventsMonitor}} uses the {{eventFactoryFactory}} bean to create {{EventFactory}} instances to serialize rows from a given source to Java event objects (aka DTOs).

The {{OracleEventsMonitor}} instance are wrapped in {{EventMonitorDatabus}} object (the {{dbDatabus}} bean) which provides connections for the {{databusConnectionPool}} pool. 

The pull process is managed by the {{eventBufferDatabusConnectionPushImpl}} bean of type {{DatabusConnectionPushImpl}}. It reads the events passed through the {{Databus}} chain of objects and invokes the callbacks. Ultimately the {{eventBufferPopulateCallback}} callback writes the DTOs to the event buffer.

*Requests from the clients* are handled by {{DatabusRelayServlet}} which translates those to calls to the {{eventBuffer}} bean. If the events are in the buffer, they are immediately returned. If the events are no longer in the buffer, the {{eventBuffer}} bean proxies the request to the {{relayOriginDatabus}} which goes to the {{OracleEventsMonitor}} and the Oracle database.

*On service shutdown*, {{eventBuffer}} uses the {{marshallerFactory}} to serialize events to the {{eventStorage}} which is most often a "cache" file. Similarly, *on service startup* {{eventBuffer}} loads initial the events from the cache file.

h2. Clients

Coming soon

h1. Core Interfaces

{anchor:iface_Databus}
h2. {{Databus<K, V>}}

The interface provides the ability to create [Databus connections|#iface_DatabusConnection].

{code}
public interface Databus<K,V>
{
  /**
   * Opens a connection to the databus. Don't forget to call {@link DatabusConnection#close()} when
   * you are done.
   *
   * @param sinceScn the unique scn since when to read event in this connection 
   */
   DatabusConnection<K,V> openConnection(long sinceScn) throws DatabusException;
}
{code}

Notable implementing classes

* [{{EventBuffer<K,V>}}|#class_EventBuffer] - Java memory heap storage for Databus events
* [{{EventsMonitorDatabus<K,V>}}|#class_EventsMonitorDatabus] - manages events from an [{{EventsMonitor}}|#iface_EventsMonitor]
* {{EventsMonitorDatabusWithPool<K,V>}} - A Databus that uses a pool to provide the connections.
* [{{HttpDatabus}}|#class_HttpDatabus] - The HTTP databus relay client.

{anchor:iface_DatabusConnection}
h2. {{DatabusConnection<K, V>}}

The interface provides methods for reading events over a Databus connection.

{code}
public interface DatabusConnection<K,V>
{
  /** Returns the end of period (the last sequence number seen) of this connection (will change as you call getUpdates(Timespan,EventCallback<K,V>)}) */
  long getEndOfPeriod();

  /**
   * Registers the sources to get updates. getUpdates() will return events for the registered sources.
   *
   * @param sources the sources to get updates
   */
  void registerSources(Source... sources) throws NoSuchSourceException, DatabusException;

  /**
   * Retrieves the updates and calls the callback when there are events.
   *
   * @param timeout how long to wait
   * @return the summary of events (may be <code>null</code>)
    */
  EventsSummary getUpdates(Timespan timeout, EventCallback<K,V> callback) throws DatabusException;

  /** Call this method when you are done */
  void close() throws DatabusException;
}
{code}

Notable implementing classes

* {{EMDatabusCx<K,V>}}/{{EventsMonitorDatabusConnection<K,V>}} - Implementation of the databus connection using an [{{EventsMonitor<K,V>}}|#iface_EventsMonitor]. The main difference is that in the case of {{EMDatabusCx<K,V>}} clients may only be interested in a subset of sources that are registered with the underlying EventsMonitor 
* {{HttpDatabusConnection}} - A {{DatabusConnection}} that uses HTTP to talk to a databus relay server.
* {{EventBufferDatabusConnection<K,V>}} - Implements the databus connection when talking to an [{{EventBuffer}}|#class_EventBuffer]

{anchor:iface_EventsMonitor}
h2. {{EventsMonitor<K, V>}}

Provides an interface for monitoring for changes in a set of Databus sources. One needs to register the sources the are interested. Then they can continuously call {{waitForEvent()}} and {{getEvents()}}. 

{code}
public interface EventsMonitor<K,V> extends Shutdownable
{
  /** Registers a single source. */
  void registerSource(Source source) throws NoSuchSourceException, DatabusException;

  /** Registers multiple sources. */
  void registerSources(Source... sources) throws NoSuchSourceException, DatabusException;

  /**
   * Wait (no longer than the timeout) for an event.
   * @return the name of the sources that triggered the event (or <code>null</code> if no event
   * before the timeout)
   */
  Source[] waitForEvent(Timespan timeout) throws DatabusException;

  /**
   * Retrieves all the events from the sources that happened after (strictly) the provided
   * scn. Note that for consistency you should call this method with the array returned
   * by {@link #waitForEvent(Timespan)}.
   * <p>
   * Note that the returned {@link EventsSummary#getEndOfPeriod()} is <b>never</b>
   * less than the input <code>sinceScn</code>.  For example, if you call
   * this method with a sinceScn of 1234, the resulting endOfPeriod will be either:
   * <ul>
   * <li>1234, if no events have occurred</li>
   * <li>a number greater than 1234, if one or more events have occurred</li>
   * </ul>
   * 
   * @param sources
   * @param sinceScn provide -1 if you are interested only in the max scn, in which case
   * the callback will return an events summary which contains the max scn
   * @param callback the callback that will be called for events
   * @return a summary of events read (never <code>null</code>)
   */
  EventsSummary getEvents(Source[] sources, long sinceScn, EventCallback<K,V> callback)
    throws NoSuchSourceException, DatabusException;

  /**
   * Return the maxScn.  This is always &gt;= 0, it is never negative.
   * Specifically, it is never -1 (that is, it is never
   * {@link EventsSummary#NO_END_OF_PERIOD}). 
   */
  long getMaxScn(Source[] sources)
    throws NoSuchSourceException, DatabusException;
}
{code}

Notable implementing classes

* [{{OracleEventsMonitor<K,V>}}|#class_OracleEventsMonitor] - monitors for new events in a Oracle database

{anchor:iface_MaxSCNReader}
h2. {{MaxSCNReader}}

Reads the SCN that has been successfully processed most recently.

{code}
public interface MaxSCNReader
{
  public long getMaxScn() throws DatabusException;
}
{code}

Notable implementing classes

* {{CacheUpdateDataWatermarkReader}} - This class is designed to be used by a cache maintenance task. Used in member2 replication and miniprofile replication
* {{CacheUpdateMaxSCNReader}} - does not seem to be used anywhere
* {{ConstantMaxSCNReader}}/{{FixedValueMaxSCNReader}} - always returns a fixed SCN
* [{{EventBuffer<K,V>}}|#class_EventBuffer] - Java memory heap storage for Databus events; the SCN returned is that of the last event period
* {{MaxSCNReaderDatabusImpl}} - An implementation that uses a [Databus|#iface_Databus] to read the max SCN.  This class makes use of the convention that calling {{Databus.openConnection(EventsSummary.NO_END_OF_PERIOD)}} instructs the databus connection to simply return the current max SCN, without processing any events.
* {{MaxScnReaderWriterImplWithMaxScnKey}} - reads the maximum SCN from a column in the {{MAX_SCN}} table in a database. Used in {{subscriptions/replication-cmpt}}
* [{{DatabusConnectionPushImpl<K,V>}}|#class_DatabusConnectionPushImpl] - Provides a push API to a Databus callback; the class returns the last seen scn
* [{{FileEventStorage<K,V>}}|#class_FileEventStorage] - stores events in a disk file as a single period; the class returns the last SCN in the stored period
* {{FileMaxSCNHandler}} - This class reads and saves max SCN in a text file.
* {{ParameterizedMaxScnMgr}} - Stores and reads current Max SCN values from a predetermined table allowing to track sources from multiple schemas. Used in {{pprofile/rep-ds-cmpt}}, {{profile/ds-databus-cmpt/}}, {{flex/rep-ds-cmpt}}, {{snapshot/ds-databus-cmpt}}

{anchor:iface_MaxSCNWriter}
h2. {{MaxSCNWriter}}

Writes the SCN that has been successfully processed most recently.

{code}
public interface MaxSCNWriter
{
  /** Saves max scn */
  void saveMaxScn(long endOfPeriod) throws DatabusException;
}
{code}

Notable implementing classes

* {{FileMaxSCNHandler}} - This class reads and saves max SCN in a text file.
* {{ParameterizedMaxScnMgr}} - Stores and reads current Max SCN values from a predetermined table allowing to track sources from multiple schemas. Used in {{pprofile/rep-ds-cmpt}}, {{profile/ds-databus-cmpt/}}, {{flex/rep-ds-cmpt}}, {{snapshot/ds-databus-cmpt}}

{anchor:iface_EventStorage}
h2. {{EventStorage<K,V>}}

Interface for storing events to external storage.

{code}
public interface EventStorage<K,V> extends MaxSCNReader
{
  /**
   * @return the sources that the storage handles
   * @throws DatabusException if there is a problem */
  Source[] getSources() throws DatabusException;

  /**
   * @return the event period that represents this storage
   * @throws NoSuchSourceException when the source does not exist
   * @throws DatabusException if there is a problem */
  EventPeriod<K,V> getEventPeriod() throws NoSuchSourceException, DatabusException;

  /**
   * Merges the provided event period in the storage.
   *
   * @param eventPeriod the period to merge
   * @throws NoSuchSourceException when the source does not exist
   * @throws DatabusException if there is a problem */
  void merge(EventPeriod<K,V> eventPeriod) throws NoSuchSourceException, DatabusException;
}
{code}

Notable implementing classes

* [{{FileEventStorage<K,V>}}|#class_FileEventStorage] - stores events in a disk file as a single period


{anchor:iface_EventCallback}
h2. {{EventCallback<K, V>}}

Defines the callback interface for consumers listening to Databus events.

{code}
public interface EventCallback<K,V>
{
  /**
   * Called at the very beginning, before calling {@link #startEvents(Source)} for the first
   * source.
   *
   * @param beginningOfPeriod the beginning of the period
   */
  void startEvents(long beginningOfPeriod);

  /**
   * Called for a source, before calling {@link #onEvent(Event<K,V>)}.
   *
   * @param source the source of the following events
   */
  void startEvents(Source source);

  /**
   * Called back when an event is available.
   *
   * @param event the available event*/
  void onEvent(Event<K,V> event);

  /**
   * Called when all events for the given source have been provided.
   *
   * @param source the source of the previous events
   */
  void endEvents(Source source);

  /**
   * Called at the very end, after calling {@link #endEvents(Source)} for the last source.
   *
   * @param summary summary of events read (if <code>null</code> signifies that an error
   * occurred after {@link #startEvents(long)} was called, so what was read should be discarded)
   */
  void endEvents(EventsSummary summary);
}
{code}

Notable implementing classes

* {{EventMarshalCallback<K,V>}} - a callback used for serializing event DTOs over the wire from the relay to the client
* {{EventUnmarshalCallback}} - a callback used for deserializing event DTOs over the wire at the client
* {{SourceChooserEventCallback<K,V>}} - maps Sources to [{{SingleSourceEventHandlers<K,V>}}|#iface_SingleSourceEventHandler]
* {{InstrumentedEventCallback<K,V>}} - keep track of the time spent in the callback and the number of events for each source. See also [Databus Logging].
* {{LastWriteTimeTrackerEventCallback<K, V>}} - This class saves the maximum timestamp from the incoming databus events, and provides that timestamp via the {{LastWriteTimeTracker}} interface.
* {{LatencyStatsEventCallback<K, V>}} - track databus latency statistics per source in a sliding window
* {{SaveDataWatermarkEventCallback<K,V>}} - Saves the dataWatermark (max SCN and timestamp) for each event cycle.
* {{SaveMaxSCNEventCallback<K,V>}} - Saves the latest SCN to a [{{MaxSCNWriter}}|iface_MaxSCNWriter]

{anchor:iface_SingleSourceEventHandler}
h3. {{SingleSourceEventHandler<K,V>}}

Handles events from a single source.

{code}
public interface SingleSourceEventHandler<K,V>
{
  /** Called back when an event is available. */
  public void onEvent(Event<K,V> event) throws Exception;
  
  /**Called before calling {@link #onEvent(Event)}. */
  public void startEvents() throws Exception;

  /** Called when all events for the given source have been provided. */
  public void endEvents() throws Exception;
}
{code}

Notable implementing classes 

* {{BufferedSingleSourceEventHandler<K,V>}} - collects events up to a provided size before dispatching to the real handler of type [{{SingleSourceBatchEventsHandler<K,V>}}|#iface_SingleSourceBatchEventsHandler].

{anchor:iface_SingleSourceBatchEventsHandler}
h3. {{SingleSourceBatchEventsHandler<K,V>}}

Handles events from a single source by batch.

{code}
public interface SingleSourceBatchEventsHandler<K,V>
{
  /**
   * Called back when events are available. */
  public void onEventsBatch(Collection<Event<K,V>> events) throws Exception;
}
{code}

{anchor:iface_EventFactory}
h2. {{EventFactory<K,V>}}

Creates an event object from a database row.

{code}
public interface EventFactory<K,V>
{
  /**
   * Given the result set, read the values out of it (using <code>ResultSet.getXXX</code>) methods. Do not call
   * {@link ResultSet#next()} in this method.
   */
  Event<K,V> createEvent(long scn, long timestamp, ResultSet row, int idx)
    throws SQLException, DatabusException;
}
{code}

Implementing classes are domain-specific.

h1. Core Classes

{anchor:class_EventBuffer}
h2. {{EventBuffer<K,V>}}

Stores Databus events in Java heap memory.

h3. Implemented interfaces

* [{{Databus<K, V>}}|#iface_Databus]
* [{{MaxSCNReader}}|#iface_MaxSCNReader]
* {{Destroyable}}

h3. Configuration and spring wiring

* {{databus}} - the origin [{{Databus}}|#iface_Databus] to be used if the requested events are not in the buffer
* {{eventStorage}} - [{{EventStorage}}|#iface_EventStorage] from where events are loaded on startup and where events are stored on shutdown
* {{delegateFetchOldEvents}} - a flag that enables the use of the origin {{databus}} when events are not longer in the buffer
* {{maxEvents}} - max number of events to be stored in the buffer

{anchor:class_DatabusConnectionPushImpl}
h2. {{DatabusConnectionPushImpl<K,V>}}

Provides a push API to a Databus callback. 

h3. Implemented interfaces

* {{Shutdownable}}
* {{DatabusConnectionPush<K,V>}} - does not provide useful API
* {{EventsSummaryListenerContainer}}

h3. Configuration and spring wiring

* {{databus}} - the [{{Databus<K,V>}}|#iface_Databus] where events are pulled from 
* {{maxSCNReader}} - [{{MaxSCNReader}}|#iface_MaxSCNReader] which provides the SCN when pulling new events
* {{timeout}} - the timeout when pulling events
* {{isFirstUpdateSynchronous}} - try to get the first event period on start up
* {{sources}} - list of Databus {{Source}}s whose change events are to be pulled
* {{listener}} - [{{EventCallback<K, V>}}|#iface_EventCallback] to call for incoming events
* {{name}} - name for monitoring/debugging purposes
* {{errRecoveryTimespan}} - time to spend in {{PAUSED_DUE_TO_ERRORS}} state before retrying to recover from an error
* {{maxNumConsecutiveExceptions}} - it does not appear to be used 
* {{postExceptionDelaySeedTimespan}} - it does not appear to be used
* {{maxStartupErrRecoveryTimespan}} - maximum time to try to recover from errors on start up
* {{waitForShutdownTimespan}} - maximum time to wait for a shutdown
* {{startInPausedMode}} - start the relay in {{PAUSED_BY_USER}} state. (Why?)


{anchor:class_OracleEventsMonitor}
h2. {{OracleEventsMonitor<K,V>}}

Monitors for new events in an Oracle database.

h3. Implemented interfaces

* [{{EventsMonitor<K,V>}}|#iface_EventsMonitor]

h3. Configuration and spring wiring

* {{dataSource}} - Oracle {{DataSource}}
* {{eventFactoryFactory}} - a factory for [{{EventFactory<K,V>}}|#iface_EventFactory] objects
* {{hints}} - a {{Map<String, String>}} which provides database hints for sources;
* {{useConfigAlertDelay}} - if {{true}} sleeps {{alertDelay}} between checks for events in the database; if {{false}}, uses a stored procedure callback to check for new events
* {{alertDelay}} - the time to wait between checks for new events if {{useConfigAlertDelay}} is {{true}} 
* {{chunkedScnThreshold}} - if >0, specifies the threshold which triggers the "chunking mode". The threshold is the difference between the maximum SCN in the database and the maximum SCN of the relay/client. This also specifies the SCN chunking factor in chunking mode if {{useRowChunking}} is {{false}}.
* {{getMaxScnDelay}} - minimum time to wait between checks for "chunking mode". This is needed because the checks invoke an expensive {{getMaxSCN}} call to the database.
* {{useRowChunking}} - if {{true}} each {{readEvents()}} call to the database will read {{rowsPerChunk}} rows in chunking mode; if {{false}}, each {{readEvents()}} call in chunking mode will check a chunk of {{chunkedScnThreshold}} scn values in {{sy$txlog}} for new updates. The latter may cause multiple calls to the database if there is a big range of SCN values with no updates.    
* {{rowsPerChunk}} - the number of rows to read in row chunking mode ({{useRowChunking}} is {{true}}).

{anchor:class_EventsMonitorDatabus}
h2. {{EventsMonitorDatabus<K,V>}}

{anchor:class_FileEventStorage}
h2. {{FileEventStorage<K,V>}}

Stores its events in a disk file. The events are loaded from the file the first time that {{getEventPeriod()}} is called. 

The events are saved to the file when {{merge()}} is called. Note that in this implementation, the {{EventPeriod}} provided *completely overwrite* the existing events (if any) in the disk file.

h3. Implemented interfaces

* {{Destroyable}}
* [{{EventStorage<K,V>}}|#iface_EventStorage]

h3. Configuration and spring wiring

* {{sources}} - a list of Databus {{Source}}s 
* {{cacheFile}} - the file where events are stored;
* {{marshallerFactory}} - a factory for event marshallers
* {{ifEmptyMaxSCNReader}} - a reader for the initial SCN if the storage is empty


{anchor:class_HttpDatabus}
h2. {{HttpDatabus}}


h1. Other Classes

{anchor:class_DatabusConnectionPoolImpl}
h2. {{DatabusConnectionPoolImpl<K,V>}}

Implements a pool of [Databus connections|#iface_DatabusConnection]


