\subsection{Event Model and Consumer API}

\lstset{basicstyle=\small}


There are two versions of the consumer API, one that is callback driven and another that is iterator-based. 
At a high-level, there are eight main methods on the Databus callback API.
%%We show the callback based API at Listing~\ref{listing:DatabusConsumerAPI}.   
%%\begin{algorithm}
%%\lstset{caption={Databus Consumer API},label=listing:DatabusConsumerAPI}
%%\begin{lstlisting}
%%interface DatabusEventListener
%%{
%%  Result onStartDataEventSequence(SCN startScn);
%% Result onEndDataEventSequence(SCN endScn);
%% Result onStartSource(String source, 
%%                       Schema srcSchema);
%%  Result onEndSource(String source, 
%%                     Schema srcSchema);
%%  Result onDataEvent(DbusEvent e, 
%%                     DbusEventDecoder decoder);
%%  Result onCheckpoint(SCN checkpointScn);
%%  Result onRollback(SCN rollbackScn);
%%  Result onError(SCN rollbackScn);
%%}
%%\end{lstlisting}
%%\end{algorithm}

\begin{itemize*}
\item \emph{onStartDataEventSequence}: the start of a sequence of data events from an events consistency window.
\item \emph{onStartSource}: the start of data events from the same Databus source (e.g. Oracle table). 
\item \emph{onDataEvent}: a data change event for the current Databus source.
\item \emph{onEndSource}: the end of data change events from the same Databus source.
\item \emph{onEndDataEventSequence}: the end of a sequence of data events with the same SCN.
\item \emph{onCheckpoint}: a hint from the Databus client library that it wants to mark the point in the stream identified by the SCN as a recovery point
\item \emph{onRollback}: Databus has detected a recoverable error while processing the current event consistency window and it will rollback to the last successful checkpoint.
\item \emph{onError}: Databus has detected a unrecoverable error and it will stop processing the event stream.
\end{itemize*}.

The above callbacks denote the important points in the stream of Databus change events. A typical sequence of callbacks follows the pattern below.

\begin{verbatim}
onStartDataEventSequence(startSCN)
    onStartSource(Table1)
        onDataEvent(Table1.event1)
               ...
        onDataEvent(Table1.eventN) 
    onEndSource(Table1)
    onStartSource(Table2)
        onDataEvent(Table2.event1) 
              ...
        onDataEvent(Table2.eventM)
    onEndSource(Table2)
        ... 
onEndDataEventSequence(endSCN)
\end{verbatim}

Intuitively, the Databus client communicates with the consumer: "Here is the next batch of changes in the watched tables (sources). The changes are broken down by tables. Here are the changes in the first table, then the changes to the next table, etc. All the changes represent the delta from the previous consistent state of the database to the following consistent state."

The contract on all of the callbacks is that the processing code can return a result code denoting a successful processing of the callback, recoverable or unrecoverable error. Failures to process the callback within the allocated time budget or throwing an exception, results in a recoverable error.
In cases of recoverable errors, the client library will rollback to the last successful checkpoint and replay the callbacks from that point.

The offloading of state-keeping responsibility from the consumer simplifies the consumer recovery. The consumer or a newly spawned consumer can rewind back to the last known good checkpoint. For instance, if the consumer is stateful, they just need to tie the state that they are keeping with the checkpoint of the stream. On failure, the new consumer can read the state and the checkpoint associated with it and just start consuming from that point. If the stream consumption is idempotent, then the checkpoint can be maintained lazily as well. 

